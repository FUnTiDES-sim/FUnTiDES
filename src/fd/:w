#ifndef FDTDKERNEL_HPP
#define FDTDKERNEL_HPP

struct FDTDKernel
{

  //innerpoints
  int inner3D(const int nx, const int ny, const int nz,
         const int x3, const int x4,
         const int y3, const int y4,
         const int z3, const int z4,
         const int lx, const int ly, const int lz,
         const float coef0,
         FDTDMODELS &myModels ) const
  {
      LOOP3DHEAD
      float lapx=(myModels.coefx[1]*(myModels.pn[IDX3_l(i+1,j,k)]+myModels.pn[IDX3_l(i-1,j,k)])
                 +myModels.coefx[2]*(myModels.pn[IDX3_l(i+2,j,k)]+myModels.pn[IDX3_l(i-2,j,k)])
                 +myModels.coefx[3]*(myModels.pn[IDX3_l(i+3,j,k)]+myModels.pn[IDX3_l(i-3,j,k)])
                 +myModels.coefx[4]*(myModels.pn[IDX3_l(i+4,j,k)]+myModels.pn[IDX3_l(i-4,j,k)]));
      float lapy=(myModels.coefy[1]*(myModels.pn[IDX3_l(i,j+1,k)]+myModels.pn[IDX3_l(i,j-1,k)])
                 +myModels.coefy[2]*(myModels.pn[IDX3_l(i,j+2,k)]+myModels.pn[IDX3_l(i,j-2,k)])
                 +myModels.coefy[3]*(myModels.pn[IDX3_l(i,j+3,k)]+myModels.pn[IDX3_l(i,j-3,k)])
                 +myModels.coefy[4]*(myModels.pn[IDX3_l(i,j+4,k)]+myModels.pn[IDX3_l(i,j-4,k)]));
      float lapz=(myModels.coefz[1]*(myModels.pn[IDX3_l(i,j,k+1)]+myModels.pn[IDX3_l(i,j,k-1)])
                 +myModels.coefz[2]*(myModels.pn[IDX3_l(i,j,k+2)]+myModels.pn[IDX3_l(i,j,k-2)])
                 +myModels.coefz[3]*(myModels.pn[IDX3_l(i,j,k+3)]+myModels.pn[IDX3_l(i,j,k-3)])
                 +myModels.coefz[4]*(myModels.pn[IDX3_l(i,j,k+4)]+myModels.pn[IDX3_l(i,j,k-4)]));
      myModels.pnp1[IDX3_l(i,j,k)]=2.*myModels.pn[IDX3_l(i,j,k)]-myModels.pnm1[IDX3_l(i,j,k)]
                         +myModels.vp[IDX3(i,j,k)]*(coef0*myModels.pn[IDX3_l(i,j,k)]+lapx+lapy+lapz);
      LOOP3DEND
      return 0;
  }

  int pml3D(const int nx, const int ny, const int nz,
             const int x3, const int x4, 
             const int y3, const int y4, 
             const int z3, const int z4,
             const int lx, const int ly, const int lz,
             const float coef0,
             FDTDMODELS &myModels ) const
  {
       LOOP3DHEAD
       float lapx=(myModels.coefx[1]*(myModels.pn[IDX3_l(i+1,j,k)]+myModels.pn[IDX3_l(i-1,j,k)])
                 +myModels.coefx[2]*(myModels.pn[IDX3_l(i+2,j,k)]+myModels.pn[IDX3_l(i-2,j,k)])
                 +myModels.coefx[3]*(myModels.pn[IDX3_l(i+3,j,k)]+myModels.pn[IDX3_l(i-3,j,k)])
                 +myModels.coefx[4]*(myModels.pn[IDX3_l(i+4,j,k)]+myModels.pn[IDX3_l(i-4,j,k)]));
      float lapy=(myModels.coefy[1]*(myModels.pn[IDX3_l(i,j+1,k)]+myModels.pn[IDX3_l(i,j-1,k)])
                 +myModels.coefy[2]*(myModels.pn[IDX3_l(i,j+2,k)]+myModels.pn[IDX3_l(i,j-2,k)])
                 +myModels.coefy[3]*(myModels.pn[IDX3_l(i,j+3,k)]+myModels.pn[IDX3_l(i,j-3,k)])
                 +myModels.coefy[4]*(myModels.pn[IDX3_l(i,j+4,k)]+myModels.pn[IDX3_l(i,j-4,k)]));
      float lapz=(myModels.coefz[1]*(myModels.pn[IDX3_l(i,j,k+1)]+myModels.pn[IDX3_l(i,j,k-1)])
                 +myModels.coefz[2]*(myModels.pn[IDX3_l(i,j,k+2)]+myModels.pn[IDX3_l(i,j,k-2)])
                 +myModels.coefz[3]*(myModels.pn[IDX3_l(i,j,k+3)]+myModels.pn[IDX3_l(i,j,k-3)])
                 +myModels.coefz[4]*(myModels.pn[IDX3_l(i,j,k+4)]+myModels.pn[IDX3_l(i,j,k-4)]));

       float lap=coef0*myModels.pn[IDX3_l(i,j,k)]+lapx+lapy+lapz;

       myModels.pnp1[IDX3_l(i,j,k)]=((2.-myModels.eta[IDX3_eta1(i,j,k)]*myModels.eta[IDX3_eta1(i,j,k)]
                  +2.*myModels.eta[IDX3_eta1(i,j,k)])*myModels.pn[IDX3_l(i,j,k)]
                  -myModels.pnm1[IDX3_l(i,j,k)]
                  +vp[IDX3(i,j,k)]*(lap+phi[IDX3(i,j,k)]))/(1.+2.*myModels.eta[IDX3_eta1(i,j,k)]);

       myModels.phi[IDX3(i,j,k)]=(myModels.phi[IDX3(i,j,k)]-((myModels.eta[IDX3_eta1(i+1,j,k)]-myModels.eta[IDX3_eta1(i-1,j,k)])
                  *(myModels.pn[IDX3_l(i+1,j,k)]-myModels.pn[IDX3_l(i-1,j,k)])*hdx_2
                  +(myModels.eta[IDX3_eta1(i,j+1,k)]-myModels.eta[IDX3_eta1(i,j-1,k)])
                  *(myModels.pn[IDX3_l(i,j+1,k)]-myModels.pn[IDX3_l(i,j-1,k)])*hdy_2
                  +(myModels.eta[IDX3_eta1(i,j,k+1)]-myModels.eta[IDX3_eta1(i,j,k-1)])
                  *(myModels.pn[IDX3_l(i,j,k+1)]-myModels.pn[IDX3_l(i,j,k-1)])*hdz_2))
                  /(1.+myModels.eta[IDX3_eta1(i,j,k)]);

     LOOP3DEND
     return(0);
  }

  // swap wavefields
  int swapWavefields( FDTDGRIDS &myGrids, 
		     vectorRealView const & pnp1,
		     vectorRealView const & pn  ,
		     vectorRealView const & pnm1) const
  {
    int nx=myGrids.nx;
    int ny=myGrids.ny;
    int nz=myGrids.nz;

    int lx=myGrids.lx;
    int ly=myGrids.ly;
    int lz=myGrids.lz;

#ifdef USE_RAJA
     RAJANestedLoop(0,0,0,nx,ny,nz)
     {
        pnm1[IDX3_l(i,j,k)]=pn[IDX3_l(i,j,k)];
        pn[IDX3_l(i,j,k)]=pnp1[IDX3_l(i,j,k)];
     });
#elif defined USE_KOKKOS
     Kokkos::parallel_for(Kokkos::MDRangePolicy<Kokkos::Rank<3>>({0,0,0},{nz+2*lz,nx+2*lx,ny+2*ly}),KOKKOS_LAMBDA(int K,int I,int J)
     {
        int i=I-lx;
        int j=J-ly;
        int k=K-lz;
        pnm1[IDX3_l(i,j,k)]=pn[IDX3_l(i,j,k)];
        pn[IDX3_l(i,j,k)]=pnp1[IDX3_l(i,j,k)];
     });
#else
#ifdef USE_OMP
      #pragma omp parallel for collapse(3)
#endif
      for( int i=0; i<nx;i++)
      {
         for( int j=0; j<ny;j++)
         {
            for( int k=0; k<nz;k++)
            {
	       pnm1[IDX3_l(i,j,k)]=pn[IDX3_l(i,j,k)];
               pn[IDX3_l(i,j,k)]=pnp1[IDX3_l(i,j,k)];
            }
         }
      }
#endif
      return(0);
  }

  // compute one step
  int computeOneStep( FDTDGRIDS &myGrids,
                     const float coef0,
                     FDTDMODELS &myModels ) const
  {
    //printf("INFO INFO: coef0=%f \n", coef0);
    //for (int index=0; index<150; index++)
     // printf("INFO INFO: eta[index]=%f \n", eta[index]);

    int nx=myGrids.nx;
    int ny=myGrids.ny;
    int nz=myGrids.nz;

    int lx=myGrids.lx;
    int ly=myGrids.ly;
    int lz=myGrids.lz;
    
    int x1=myGrids.x1;
    int x2=myGrids.x2;
    int x3=myGrids.x3;
    int x4=myGrids.x4;
    int x5=myGrids.x5;
    int x6=myGrids.x6;

    int y1=myGrids.y1;
    int y2=myGrids.y2;
    int y3=myGrids.y3;
    int y4=myGrids.y4;
    int y5=myGrids.y5;
    int y6=myGrids.y6;

    int z1=myGrids.z1;
    int z2=myGrids.z2;
    int z3=myGrids.z3;
    int z4=myGrids.z4;
    int z5=myGrids.z5;
    int z6=myGrids.z6;

    float hdx_2=myGrids.hdx_2;
    float hdy_2=myGrids.hdy_2;
    float hdz_2=myGrids.hdz_2;

    //up
    pml3D(nx,ny,nz,0,nx,0,ny,z1,z2,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);
    //front
    pml3D(nx,ny,nz,0,nx,y1,y2,z3,z4,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);
    //left
    pml3D(nx,ny,nz,x1,x2,y3,y4,z3,z4,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);
    //inner points
    inner3D(nx,ny,nz,x3,x4,y3,y4,z3,z4,lx,ly,lz,coef0,myGrids);
    //right
    pml3D(nx,ny,nz,x5,x6,y3,y4,z3,z4,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);
    //back
    pml3D(nx,ny,nz,0,nx,y5,y6,z3,z4,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);
    // bottom
    pml3D(nx,ny,nz,0,nx,0,ny,z5,z6,lx,ly,lz,coef0,hdx_2,hdy_2,hdz_2,myGrids);

    return(0);
  }

  // add RHS term
  int addRHS( FDTDGRIDS &myGrids,
             const int itSample,
             vectorRealView const & RHSTerm,
             vectorRealView const & vp, 
             vectorRealView const & pn) const
  {

    int ny=myGrids.ny;
    int nz=myGrids.nz;

    int lx=myGrids.lx;
    int ly=myGrids.ly;
    int lz=myGrids.lz;
    
    int xs=myGrids.xs;
    int ys=myGrids.ys;
    int zs=myGrids.zs;

#ifdef USE_RAJA
     RAJANestedLoop(xs,ys,zs,xs+1,ys+1,zs+1)
     {
       pn[IDX3_l(i,j,k)]+=vp[IDX3(i,j,k)]*RHSTerm[itSample];
     });
#elif defined USE_KOKKOS
    Kokkos::parallel_for(Kokkos::MDRangePolicy<Kokkos::Rank<3>>({xs,xs,zs},{xs+1,ys+1,zs+1}),KOKKOS_LAMBDA(int i,int j,int k)
    {
    pn[IDX3_l(i,j,k)]+=vp[IDX3(i,j,k)]*RHSTerm[itSample];
    });
#else
    pn[IDX3_l(xs,ys,zs)]+=vp[IDX3(xs,ys,zs)]*RHSTerm[itSample];
#endif
    return(0);
  }


};
#endif //FDTDKERNE_HPP

